# Codata and corecursion: cleaning before whistling

By using codata and corecursion, we can decompose `lazy_mrsc` into two stages

```text
    lazy_mrsc ≗ prune_cograph ∘ build_cograph
```

where `build_cograph` constructs a (potentially) infinite tree,
while `prune_cograph` traverses this tree and turns it into
a lazy graph (which is finite).

Note that, unlike Haskell, Scala is a "strict" language. Namely, by default,
function/method parameters are passed by value (but there is a way to make
some parameters passed by name). Hence, we model codata and corecursion by
passing some parameters by name and delaying the evaluation of some
expressions `e` by turning them into functions `() => e`.

## Lazy cographs of configurations

A `LazyCograph[C]` represents a (potentially) infinite set of
graphs of configurations whose type is `Graph[C\` (see `Graph.scala`).

A "naive" definition of `LazyCograph[C]` looks as follows:

```scala
sealed trait LazyCograph[+C]

case object Empty8 extends LazyCograph[Nothing]

case class Stop8[C](c: C) extends LazyCograph[C]

case class Build8[C](c: C, lss: () => List[List[LazyCograph[C]]])
  extends LazyCograph[C]
```

where `8` is used instead of `∞` in identifiers.

Note that `LazyCograph[C]` differs from `LazyGraph[C]` in that the evaluation
of `lss` in build-nodes is delayed.

A drawback of such a definition is that the argument `lss` of `Build8`
has to be delayed and forced explicitly. In addition, when forced, `lss` can be
evaluated several times. Thus, the actual implementation of `Build8` is
the following:

```scala
  case class Build8[C] private (val c: C, val lss: () => List[List[LazyCograph[C]]])
    extends LazyCograph[C]

  object Build8 {
    def apply[C](c: C, lss: => List[List[LazyCograph[C]]]): LazyCograph[C] = {
      lazy val lssVal = lss
      Build8[C](c, () => lssVal)
    }

    def unapply[C](arg: Build8[C]): Some[(C, List[List[LazyCograph[C]]])] =
      Some(arg.c, arg.lss())

```

The point is that now `Build8.apply` is a function, whose second argument
is passed by name, while `Build8.unapply` forces the second argument during
pattern matching. Besides, the result of evaluating `lss` is memoized
in `lssVal`.

## Building lazy cographs

Lazy cographs are produced by the function `build_cograph`

```scala
  def build_cograph_loop(h: History)(c: C): LazyCograph[C] =
    if (isFoldableToHistory(c, h))
      Stop8(c)
    else
      Build8(c,
        develop(c)
          .map(_.map(build_cograph_loop(c :: h))))

  def build_cograph(c: C): LazyCograph[C] =
    build_cograph_loop(Nil)(c)
```

which can be derived from the function `lazy_mrsc` by just removing
the machinery related to whistles.

## Pruning lazy cographs

A lazy cograph can be pruned by means of the function `prune_cograph`
to obtain a finite lazy graph.

```scala
  def prune_cograph_loop(h: History): LazyCograph[C] => LazyGraph[C] = {
    case Empty8 => Empty
    case Stop8(c) => Stop(c)
    case Build8(c, lss) =>
      if (isDangerous(h))
        Empty
      else
        Build(c,
          lss.map(_.map(prune_cograph_loop(c :: h))))
  }

  def prune_cograph(l: LazyCograph[C]): LazyGraph[C] =
    prune_cograph_loop(Nil)(l)
```

which can be derived from the function `lazy_mrsc` by removing
the machinery related to generation of nodes (since it only consumes
nodes that have been generated by `build_cograph`).

Note that, when processing a node `Build(c, lss)`, the evaluation of
`lss` has to be explicitly forced in this way: `lss()`.

`prune_cograph` and `build_cograph` are correct with respect
to `lazy_mrsc`:

```text
    prune_cograph ∘ build_cograph ≗ lazy_mrsc
```

There exists a proof of this theorem formalized in Agda.

## Promoting some cleaners over the whistle

Suppose `clean∞` is a cograph cleaner such that

```text
    clean ∘ prune_cograph ≗ prune_cograph ∘ clean∞
```

then

```text
    clean ∘ lazy_mrsc ≗
        clean ∘ prune_cograph ∘ build_cograph ≗
        prune_cograph ∘ clean∞ ∘ build_cograph
```

The good thing about `build_cograph` and `clean∞` is that they
work in a lazy way, generating subtrees by demand. Hence, evaluating

```text
    unroll( prune_cograph ∘ (clean∞ (build_cograph c)) )
```

is likely to be less time and space consuming than evaluating

```text
    unroll( clean (lazy_mrsc c) )
```

In `BigStepSc8.scala` there is defined a cograph cleaner `cl8_bad_conf`
that takes a lazy cograph and prunes subtrees containing bad
configurations, returning a lazy subgraph (which can be infinite):

```scala
  def cl8_bad_conf(bad: C => Boolean): LazyCograph[C] => LazyCograph[C] = {
    case Empty8 =>
      Empty8
    case Stop8(c) =>
      if (bad(c)) Empty8 else
        Stop8(c)
    case Build8(c, lss) =>
      if (bad(c)) Empty8 else
        Build8(c,
          lss.map(_.map(cl8_bad_conf(bad))))
  }
```

`cl8_bad_conf` is correct with respect to `cl_bad_conf`:

```text
    cl_bad_conf(bad) ∘ prune_cograph ≗ prune_cograph ∘ cl8_bad_conf(bad)
```

There exists a proof of this theorem formalized in Agda.
